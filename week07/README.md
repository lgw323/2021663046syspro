# 📝 7주차 학습 정리

## 📅 날짜
- 2025-04-18

## 📌 주제
- 프로세스(Process)의 이해와 관리 (`ps`, `kill`)
- 백그라운드/포그라운드 작업 제어 (`&`, `fg`, `bg`, `Ctrl+Z`)
- C 프로그램의 분할 컴파일과 링킹 (`gcc -c`, `gcc -o`)
- `Makefile`을 이용한 빌드 자동화
- 주요 리눅스 유틸리티 (`sort`, `history`)

---

## 📖 이론 정리

### 🔹 프로세스 (Process) 기초
- **프로세스**란 '실행 중인 프로그램'을 의미합니다. 디스크에 저장된 코드(`a.out` 등)가 메모리에 올라와 CPU에 의해 실행될 때 생명력을 갖는 개체가 됩니다.
- 각 프로세스는 고유한 ID(**PID**)를 가지며, 프로세스를 생성한 부모 프로세스(**PPID**) 정보를 가집니다.
- **컨텍스트 스위칭(Context Switching)**: CPU가 여러 프로세스를 번갈아 가며 실행할 때, 현재 실행 중인 프로세스의 상태(레지스터 값 등)를 저장하고 다음 실행할 프로세스의 상태를 불러오는 과정을 말합니다. 이를 통해 여러 프로그램이 동시에 실행되는 것처럼 보입니다.
- **프로세스 상태**: 프로세스는 실행(Running), Sleeping(대기), Stopped(정지) 등 여러 상태를 가집니다. `ps` 명령어로 현재 상태를 확인할 수 있습니다.

### 🔹 프로세스 및 작업 제어
- **포그라운드(Foreground) 작업**: 터미널에 직접 연결되어 입출력을 주고받는 작업. 한 번에 하나만 실행됩니다.
- **백그라운드(Background) 작업**: 터미널 입출력과 분리되어 뒤에서 실행되는 작업. 명령어 뒤에 `&`를 붙여 실행합니다.
- **주요 명령어 및 단축키**
  - `ps` : 현재 실행 중인 프로세스 목록과 상태를 출력합니다.
  - `sleep [초] &` : 지정된 시간 동안 대기하는 프로세스를 백그라운드로 실행하고, PID를 반환합니다.
  - `kill [PID]` : 특정 PID의 프로세스에 종료 신호(SIGTERM)를 보냅니다.
  - `Ctrl + C` : 현재 포그라운드에서 실행 중인 작업을 **강제 종료**합니다.
  - `Ctrl + Z` : 현재 포그라운드에서 실행 중인 작업을 **일시 정지**시킵니다.
  - `fg %[작업번호]` : 정지되거나 백그라운드에 있는 작업을 포그라운드로 가져옵니다.
  - `bg %[작업번호]` : 정지된 작업을 백그라운드에서 계속 실행시킵니다.
  - `nice`, `renice`: 프로세스의 실행 우선순위를 확인하거나 조정합니다.

### 🔹 C 프로그램의 분할 컴파일
- 프로그램의 규모가 커지면 기능별로 소스 파일을 분리(`main.c`, `copy.c`, `copy.h` 등)하는 것이 유지보수에 효율적입니다.
- **컴파일과 링킹**
  1.  **컴파일 (Compilation)**: 각 소스 파일(`.c`)을 기계어 코드인 **오브젝트 파일(`.o`)**로 변환하는 과정입니다. `gcc -c` 옵션을 사용합니다.
  2.  **링킹 (Linking)**: 생성된 여러 오브젝트 파일들을 하나로 묶어 최종 **실행 파일**을 만드는 과정입니다.

### 🔹 Makefile의 필요성과 기본 개념
- **필요성**: 프로젝트의 파일 개수가 많아지면, 어떤 파일을 컴파일하고 링크해야 하는지, 어떤 순서로 해야 하는지 관리하기 복잡합니다. 특히 일부 파일만 수정되었을 때 전체를 다시 컴파일하는 것은 매우 비효율적입니다.
- **Makefile**: 이 빌드 과정을 자동화하는 스크립트 파일입니다.
  - 파일 간의 의존 관계를 명시합니다.
  - **변경된 소스 파일과 관련된 부분만** 다시 컴파일하여 빌드 시간을 단축합니다.
  - 복잡한 컴파일 명령어를 `make`라는 간단한 명령으로 실행할 수 있게 해줍니다.

---

## 🛠️ 실습 내용

### 1. 백그라운드 프로세스 실행 및 제어
   - `sleep` 명령을 백그라운드로 실행하고, `ps`로 확인 후 `kill`로 종료하는 과정입니다.
   ```bash
   # 1. 100초간 대기하는 프로세스를 백그라운드로 실행 (&)
   sleep 100 &
   # [1] 12345  <- [작업번호] PID

   # 2. 현재 터미널의 프로세스 목록 확인
   ps

   # 3. PID를 이용해 sleep 프로세스 강제 종료
   kill 12345
   ```

### 2. 다중 파일 컴파일 및 Makefile 작성
   - 입력된 여러 줄의 텍스트 중 가장 긴 줄을 찾아 출력하는 프로그램을 여러 파일로 분리하고, `Makefile`로 빌드하는 과정입니다.

   #### **프로젝트 파일 작성**
   먼저, 프로젝트를 구성하는 세 개의 핵심 파일을 작성합니다.
   
   - **`copy.h` (헤더 파일)**: 공통 상수와 함수 원형을 선언합니다.
     ```c
     #define MAXLINE 100
     void copy(char from[], char to[]);
     ```
   - **`copy.c` (기능 구현 파일)**: `copy` 함수의 실제 동작을 정의합니다.
     ```c
     #include <stdio.h>
     #include "copy.h"
     /* copy: from을 to에 복사; to가 충
     분히 크다고 가정*/
     void copy(char from[], char to[])
     {
         int i;
         i = 0;
         while ((to[i] = from[i]) != '\0') {++i;}
     }
     ```
   - **`main.c` (메인 프로그램 파일)**: 프로그램의 전체 로직을 담당하며, `copy` 함수를 호출하여 사용합니다.
     ```c
     #include <stdio.h>
     #include <string.h>
     #include "copy.h"
     char line[MAXLINE]; // 입력 줄
     char longest[MAXLINE]; // 가장 긴 줄
     /*입력 줄 가운데 가장 긴 줄 프린트 */
     int main()
     {
         int len, max = 0;
         while (fgets(line,MAXLINE,stdin) != NULL) {
             len = strlen(line);
             if (len > max) {
             max = len;
             copy(line, longest);
             }
         }
         if (max > 0) // 입력 줄이 있었다면
         printf("%s", longest);
         return 0;
     }
     ```

   #### **Makefile을 이용한 빌드 및 실행**
   위에서 작성한 여러 소스 파일을 효율적으로 컴파일하고 링크하기 위해 `Makefile`을 작성합니다.

   - **`Makefile` 예시**
     ```makefile
     # 컴파일러 지정
     CC = gcc
     # 최종 실행 파일 이름
     TARGET = main
     # 오브젝트 파일 목록
     OBJS = main.o copy.o
     
     # 최종 목표(TARGET) 생성 규칙
     $(TARGET): $(OBJS)
         $(CC) -o $(TARGET) $(OBJS)
     
     # main.o 생성 규칙
     main.o: main.c copy.h
         $(CC) -c -o main.o main.c
     
     # copy.o 생성 규칙
     copy.o: copy.c copy.h
         $(CC) -c -o copy.o copy.c
     
     # 이전 빌드 파일 삭제 규칙
     clean:
         rm -f $(OBJS) $(TARGET)
     ```
   
   - **사용법**
   
     `Makefile`이 있는 디렉토리에서 아래 명령어를 사용하여 프로그램을 빌드, 실행, 그리고 정리할 수 있습니다.
     ```bash
     # Makefile 규칙에 따라 컴파일 및 링크 실행
     make
     
     # 생성된 실행 파일 실행
     ./main
     
     # 빌드 과정에서 생성된 .o 파일과 실행 파일 모두 삭제
     make clean
     ```